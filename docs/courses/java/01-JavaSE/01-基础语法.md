---
title: 基础语法
date: 2023/5/29 14:12
categories: 
 - Java
---
# 基础语法

## 常量

```java
public static final int SPRING =1;
```

> static确保只有一份，final确保不可修改，这两同时修饰的变量称做常量

常量池

Short、Int、Long：-128~127
Float、Double：没有缓存（常量池）

输入 Scanner

```JAVA
引入
import java.util.Scanner

创建对象
Scanner scan =new Scanner(System.in);

接受数据
scan.nextInt()，scan.nextDouble()，...

停止输入
scan.close()
```

## 数组

静态初始化

```java
arrayName=new type[]{element1,element2,...}
type[] arrayname={element1,element2,...}
```

动态初始化

* arrayName=new typr[length]

  整数类型默认值为 0，浮点类型默认值为 0.0，字符类型默认值为‘\u0000’布尔类型默认值为 fause，引用类型默认值为 null

## 变长形参

如果在定义方法时，在最后一个形参的类型后增加三个点...，则表明该形参可以接收多个参数值，多个参数值被当成数组传入

```java
修饰符 返回值类型 方法名（参数类型 参数，参数类型... 参数）{
//方法体
}
```

## this

区分局部变量和成员变量

本质：代表方法调用者的地址值

## lambda

lambda 可以用来简化匿名内部类的书写

lambda 表达式只能简化函数式接口的匿名内部类的写法

函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加 @FunctionalInterface 注释

```java
Arrays.sort(arr,new compar<Integer>()){
	@override
	public int compare(Integer o1,Intager o2){
		return 01-02;
	}
}
```

```java
ARRAYS.SORT(arr,(Intefer 01,Intager 02)->{
return 01-02
```

## File

File是java.io包下的类，代表与平台无关的文件和目录；

```java
package com.nowcoder.chapter3.part39;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;

/**
 * File
 */
public class IODemo1 {

    public static void main(String[] args) throws IOException {
File file = null;

// 创建
file = new File("C:/work/alpha/1.txt");
file.createNewFile();

// 删除
//file.delete();

// 改名
//file.renameTo(new File("C:/work/alpha/2.txt"));

// 判断
System.out.println("是否存在:" + file.exists());
System.out.println("是否文件:" + file.isFile());
System.out.println("是否可读:" + file.canRead());
System.out.println("是否可写:" + file.canWrite());
System.out.println("绝对路径:" + file.isAbsolute());
// 访问
System.out.println("文件名称:" + file.getName());
System.out.println("文件路径:" + file.getPath());
System.out.println("绝对路径:" + file.getAbsolutePath());
System.out.println("上级目录:" + file.getParent());
System.out.println("文件长度:" + file.length());
System.out.println("修改时间:" + file.lastModified());

// 目录操作
file = new File("C:/work/alpha/a");
file.mkdir();

System.out.println(Arrays.toString(file.listFiles()));
System.out.println(Arrays.toString(file.getParentFile().listFiles()));

// 删除,改名,判断,访问方法对目录也适用.

// 相对路径
file = new File("abc.txt");
file.createNewFile();

System.out.println("文件路径:" + file.getPath());
System.out.println("绝对路径:" + file.getAbsolutePath());
System.out.println("上级目录:" + file.getParent());
System.out.println("上级目录:" + file.getAbsoluteFile().getParent());
    }

```

## 抽象类

约束子类必须重写 `abstract`

1. 抽象方法必须在抽象类中（抽象类不一定包括抽象方法）
2. 子类必须重写抽象父类的抽象方法

> 模板模式：抽象类作为子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为模式
>
> abstract 只能修饰类和方法，它不能和 final 同时使用

## 接口

接口不提供任何实现，接口内部定义的所有的方法都是抽象方法

```cpp
[修饰符] interface 接口名 extends 父接口1,父接口2,...()
```

1. 修饰符可以是 public，也可省略，默认为包访问级别
2. 一个接口可以有多个直接接口，但接口只能继承于接口，不能继承于类

Java8 运行在接口中定义默认方法和静态方法，这两类方法可以提供方法实现

## static 关键字

含义

* static 修饰的成员是类的成员，该成员属于类，不属于单个对象

修饰

1. Java 类中可包含成员变量、方法、构造方法、初始化块、内部类；
2. 其中，static 可以修饰的是成员变量、方法、初始化块、内部类。·

类变量

1. 以 static 修饰的成员变量叫类变量（静态变量）
2. 类变量属于类，它随类的信息存储在方法区（1 份），并不随对象存储在堆区；
3. 类变量可以通过类名来访问，也可以通过对象名来访问，建议通过类名访问它

类方法

1. 以 static 修饰的方法叫类方法（静态方法）；
2. 类方法属于类，可以通过类名来访问，也可以通过对象名来访问，建议通过类名访问

静态块

1. 以 static 修饰的初始化块叫静态初始化块
2. 静态块属于类，在类加载的时候被隐式调用一次，之后便再也不会被调用了。

重要规则

* 类成员不能访问实例成员

  原因：可能出现类成员已初始化完成，但实例成员还未初始化的情况

## final 关键字

**final 关键字可用于修饰类、方法、变量；**

* final 关键字修饰的类不可以被继承
* final 关键字修饰的方法不可以被重写
* final 修饰的变量，一旦获得了初始值，就不可以被修改

**final 修饰成员变量**

* 类的变量：可在声明时指定初始值，也可在静态初始化块中指定初始值；
* 实例变量：可在声明时指定初始值，也可在普通初始化块或构造方法中指定初始值；

**final 修饰局部变量**

* 可在声明变量时指定初始值，也可在后面的代码中指定初始值

**final 修饰引用类型变量**

1. 引用类型变量，保存的仅仅是一个引用(地址)
2. final 只保证这个引用类型变量所引用的地址不会发生改变，但这个对象的内容可以发生改变

**final 变量的宏替换原则**
满足下述三个条件的变量相当于直接量

1. 使用 final 关键字修饰
2. 在声明该变量的时候置指定了初始值
3. 该初始值可以在编译时被确定

编译时，编译器会把程序中所有用到该变量的地方直接替换成它的值，这个过程叫“宏替换”

## 内部类

在类内部定义的类叫做内部类，而包含了内部类的类叫做外部类

```x86asm
class A{
	class B { }
}
```

作用

1. 内部类提供了一种新的封装方式，可以将内部类隐藏于外部类内部
2. 便于访问外部类成员，如成员内部类可以直接访问外部类私有成员
3. 对于那些仅需使用一次的类，采用内部类（匿名内部类）更方便

成员内部类

1. 定义在外部类内部，与其他成员平级
2. 可以被任意访问修饰符修饰，有四种访问级别
3. 被 static 修饰的成员内部类叫静态内部类，否则叫非静态内部类

局部内部类

* 在方法内定义的内部类叫做局部内部类，它仅仅在这个方法内部有效

匿名内部类

* 定义在方法调用之时，它没有类名，适合创建只是用一次的类

访问

```java
外部类.内部类 实例名=new 外部类().new 内部类()
```

## 枚举类

规范

1. 枚举类是特殊的类
2. 枚举类可以定义成员变量
3. 枚举类默认继承于 java.lang.Enum 类
4. 非抽象枚举类默认使用 final 修饰
5. 枚举类的构造方法默认使用 private 修饰，并且只能使用 private 修饰；
6. 枚举类的所有实例，必须在类中第一行显示列出，它们默认是public static final的

定义

```java
enum Gender{
	MALE,FEMALE;
}
```

接口

```java
    enum Gender implements Printer{
MALME,FEMALE;
public void print(){}
    }
```

```java
enum  Genders implements Printer{
AGE{
    public  void print(){ };
},
SEX{
    public void print(){ };
};
    }

```

抽象枚举类

1. 可以在枚举类中定义抽象方法，此时枚举类为抽象类，但不能用 abstract 修饰该类;
2. 枚举类需要显示创建枚举值，所以每个枚举值都需要实现抽象方法，否则会编译报错。
3. ```java
    enum Gender{
    	MALE(){public void print(){...}},
    	FEMALE(){public void print(){} };
    	public abstract void print();
    }
   ```

## 方法区

## 垃圾回收机制

当程序创建引用类型数据时，JVM会在堆内存中为之分配一块内存区。

当这份数据不再被任何变量引用时，它就成了垃圾，对应的内存区就等待垃圾回收器的回收。

## finalize 方法

定义在 `java.lang.Object` 类中：

```java
protect void finalize() thorows Throwable{}
```

1. 用于清理对象占用的资源
2. 垃圾回收器在回收某对象的内存之前，会先调用它的 finalize 方法；
3. 针对某一对象，垃圾回收器最多只会调用它的 finalize 方法一次

内存状态

强制垃圾回收

1. System.gc();
2. Runtime.getRuntime().gc();

通知垃圾回收器进行垃圾回收，但是是否回收以及回收时机依然由垃圾回收器决定

# Java 常用 API

Application Programming Interface ，应用程序接口，应用程序规范

## 系统相关类

System 类

1. System 类代表当前 Java 程序的运行平台；
2. System 类不允许被实例化，它所提供的变量和方法全是**静态的**；
3. System 类提供了代表标准输入，标准输出、错误输出的静态变量；
4. System 类提供了访问环境变量、访问系统属性、加载文件、加载动态链接库等方法。

Runtime 类

1. Runtime 类代表 Java 程序的运行环境；
2. Runtime 类符合**单例模式**，我们只能通过 getRuntime()获得该类型的唯一实例；
3. Runtime 类提供了访问 JVM 相关信息的方法，如获取 CPU 数量、获取空闲内存数等。

## 用户输入

main()的参数

```java
public static void main(String[] args){}

命令：java 字节码文件 字符串1 字符串2 ...
```

Scanner 类

Scanner 是一个文本扫描器

## String 类

String 是**不可变类**，创建 String 对象后，其内部的字符序列不能修改

构造方法

```java
String s2=new String();//创建空白字符串对象

char[] chs ={'a','b','v'};//根据字符数组创建字符串对象
Sring s4=new string(chs);

byte[] bytes={92,93};//根据字节数组创造一个新字符串对象
String s3=new String(bytes);
```

常用方法

```java
length();返回字符串长度
getButes();通过默认或指定的字符集，将字符串编码为一个字节数组
equals();String重写了该方法，用于比较当前字符串于另一个字符串的内容

```

## StringBuilder

`StringBuilder` 可以看成一个容器，创建之后里面的内容是**可变的**；提高了字符操作效率

构造方法

```java
public SringBuilder();
public SringBuilder(String str);
```

常用方法

```java
public SringBuilder append(任意类型);添加数据，并返回对象本身
public SringBuilder reverse();反转容器中的内容
public int length();返回长度（字符出现个数）
public String toSring();将内容转换为String
```

> 链式编程：
> 当我在调用一个方法时，不需要用变量接受他的结果，可以继续调用其他方法
>
> ```java
> int len=getString().substring(1).replace("a","q").lenth();
> ```

## StringJoiner

和 StringBuilder 类似，是一个内容可变的容器，但编写时更简洁

构造方法

```java
public StringJoiner(间隔符号);
public StringJoiner(间隔符号,开始符号,结束符号);
```

成员方法

```java
public StringJoiner add(添加的内容);添加数据，并返回对象本身
public int length();返回长度
public String toString();返回一个字符串（拼接后的结果）
```

## Math

Math 类**不能被实例化**，它的所有成员都是静态的，直接通过类名来访问；
Math 类提供了两个静态常量，分别是 E（自然对数的基数）和 PI（圆周率）；
Math 类提供了对数运算、指数运算、三角函数等一系列支持数学运算的方法。

```java
abs();绝对值
ceil();向上舍入
floor();向下舍入
* 取整round()
* 对数log()
* 最值max(),min()
* 乘方pow()
* 平方根sqrt()
```

## BigInteger

存取较大的数，对象一旦创建不能发生改变

构造方法

```java
public BigInteger(int num,Random rnd);获得随机大整数，范围：[0~2的num次方-1]
public BigInteger(String val);获取指定的大整数
public Bi给Integer(String val,int radix);获取指定进制的大整数 

//能获取的范围较小
//对常用的数字:-16~16进行了优化，静态
BigInteger bd=BigInteger.valueOf(100);
```

## BigDecimal

用于精确的表示和计算浮点数

创建实例

```java
BigDecimal(String val);建议优先使用，它的结果是可以预知的
BigDecimal(double val);不推荐使用，其参数是一个近似值
BigDecimal。valueoF(double val);若必须使用double，建议调用这个静态方法来创建实例
```

成员方法

```java
add()、subtract()、multiply()、divite()、pow();
```

## 正则

Matcher：文本匹配器，按照正则规则去读取字符串，从头开始读取。

Pattern 正则表达式

```java
//获取正则表达式对象
Pattern p= Pattern.compile("Java\\d{0,2}");
//获取文本匹配器的对象
//m:文本匹配器的对象
//str:大串
//p.规则
//m要在str中找符合p规则的小串
Matcher m=p.matcher(str);
//如果没有，返回false
//如果有，返回true，在底层记录子串的起始索引和结束索引+1
boolean  b=m.find();
//方法底层根据find方法记录的索引进行字符串的截取
包左不包右
String s1=m.group();

//第二次调用find的时候，会继续读取后面的内容
boolean  b=m.find();

while(m.find()){
String s=m.group();
System.out.println();
}
```

```java
\表示转义字符
\.表示任意一个字符
\w只能是单词字符
？ 1/0
+ 
{n} n 
```

## 异常

回收资源

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int score = scanner.nextInt();
try{
    if(score >= 0 && score <= 100) //正常分数输出
System.out.println(score);
    else
throw new ScoreException("分数不合法"); //抛出异常
}
catch(ScoreException str){
    System.out.println(str.getMessage()); //输出异常
}
    }
}

class ScoreException extends Exception{ //继承自异常类的分数异常处理类
    public ScoreException(String message){ //构造函数
super(message); //输入异常信息
    }
}
```

Throwable

throws

自定义异常

extends exception

throw

## Collection

Collection集合概述

* 是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素
* JDK不提供此接口的任何直接实现，它提供更具体的（如Set和List）实现

创建Collection集合的对象

* 多态的方式

## ArrayList

List 代表有序集合，它提供了根据索引来访问集合的方法：

1. ArrayList 是基于数组实现了 List 接口；
2. ArrayList 内部封装了一个长度可变的 Object []数组；
3. 默认该数组初始长度为 10，也可以通过构造器参数显示指定其初始长度；
4. 每当添加的元素个数超出数组的长度，ArrayList 会自动对长度进行扩展

```JAVA
ArrayList<String> list =new ArrayList<>();创建集合
```

```JAVA
boolean add(index,element);//将元素插入到集合指定索引处 ；
boolean remove(index);//将指定索引处的元素从集合中删除
E get(index);//从集合中返回索引处的元素；
E indexOf(element); lastIndexOf();//从集合中返回索引处的元素；
subList(1, 4));//从集合中，返回起始索引和结束索引之间的元素所组成的子集；
listIterator();//返回迭代器实例
String set(index,element);//修改元素，返回旧字符
//其他
//由于java已在底层做了些处理，打印对象不是地址值，而是集合中存储数据内容
System.out.println(list);
//在展示的时候会拿[]把所有数据进行包裹
```

```JAVA
/**
 * ArrayList
 */
public class ListDemo1 {

    public static void main(String[] args) {
List names = new ArrayList();//创建实例
names.add("Lily");
names.add("Mary");
System.out.println(names);

names.add(1, "Lucy");//添加元素
System.out.println(names);

names.remove(1);//删除元素
System.out.println(names);

for (int i = 0; i < names.size(); i++) {
    System.out.println((i + 1) + ": " + names.get(i));//获取元素
}

System.out.println(names.subList(1, 4));//截取子集
System.out.println(names.indexOf("Mary") + ", " + names.lastIndexOf("Mary"));//指定索引的元素

	//listIterator
ListIterator iterator = names.listIterator();
while (iterator.hasNext()) {
    System.out.print(iterator.next() + " ");
}
System.out.println();
while (iterator.hasPrevious()) {
    System.out.print(iterator.previous() + " ");
}
System.out.println();

// 排序
names.sort(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
String s1 = (String) o1;
String s2 = (String) o2;
if (s1 == null && s2 == null) {
    return 0;
} else if (s1 == null) {
    return -1;
} else if (s2 == null) {
    return 1;
} else {
    return s1.compareTo(s2);
}
    }
});
System.out.println(names);
    }
```

## 并发修改异常

```JAVA
public class Itarator {
    public static void main(String[] args) {
List<String> a=new ArrayList<>();
a.add("aaa");
a.add("bbb");
//增强for,可能报错
//for(Object i:a){
//    if(i.equals("aaa")){
//a.remove(i);
//    }
//    System.out.println(i);
//}
//迭代器
Iterator iterator=a.iterator();
while (iterator.hasNext()){
    Object obj=iterator.next();
    if(obj.equals("aaa")){
iterator.remove();
    }
}
System.out.println();
System.out.println(a);
    }
}
```

## LinkedList

```JAVA
/**
 * 单链链表
 */
public class Itarator {
    public static void main(String[] args) {
List<String> a=new LinkedList<>();
a.add("世事变");
a.add("活无常");
a.remove("活无常");
a.add(1,"死安眠");
a.add("乐不得");
a.add("死不掉");
System.out.println(a.subList(0,1)+a.get(1));
//比较器排序
a.sort(new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
String s1 = (String) o1;
String s2 = (String) o2;
if (s1 == null && s2 == null) {
    return 0;
} else if (s1 == null) {
    return -1;
} else if (s2 == null) {
    return 1;
} else {
    return s1.compareTo(s2);//调用元素内比较方法
}
    }
});
System.out.println(a);
    }
}
```

## Collection集合的遍历

Iterator(迭代器)

Collecton 接口中的 iterateo()方法返回 Iterator 接口的实例

```java
public class List {
    public static void main(String[] args) {
ArrayList<String> array=new ArrayList<>();
LinkedList<String> linked=new LinkedList<>();
linked.add("你是狗");
System.out.println(array);
System.out.println(linked);

//增强for循环
for(String s:array){
    System.out.println(s);
}
//普通
for (int i= 0; i < array.size() ; i++) {
    System.out.println(array.get(i));
}
//迭代器
Iterator<String> it= array.iterator();
while (it.hasNext()){
    System.out.println(it.next());
}
    }
}
```

```java
boolean hasNext();如果集合没有迭代完，则返回true
Object next();返回集合里的下一个元素
void remove();删除集合里上一次next方法返回的元素
```

# 泛型

作用

* 统一数据类型
* 把运行期的问题提前到了编译期间，避免了强制类型可能出现的异常，因为在编译阶段类型就能确定下来

细节

1. 泛型中不能写基本数据类型
2. 指定泛型的具体类型，传递数据时，可以传入该类类型与其子类
3. 如果不写泛型，默认是 Object
4. 泛型不能继承

## 泛型类

泛型类的定义格式

* 格式：修饰符 class 类名<类型>{ }
* 范例：public class Generic `<T>`{ }
  此处T可以是任意字母

```JAVA
public class GenericDemo {
    public static void main(String[] args) {
Generic<String> g1=new Generic<>();
g1.setT("零");
System.out.println(g1.getT());

Generic<Integer> g2=new Generic<>();
g2.setT(200);
System.out.println(g2.getT());
    }
}
public class Generic <T>{
    private T t;
  
    public T getT(){
return t;
    }
    public void setT(T t){
this.t=t;
    }
}

```

> 泛型类的构造方法不能是泛型方法

## 泛型方法

* 格式：修饰符 <类型> 返回值类型 方法名 (类型) { }
* 范例：public `<T>` void show (T t) { }

```JAVA
public class Generic {
    public <T> void show(T t){
System.out.println(t);
    }
}
public class GenericDemo {
    public static void main(String[] args) {
Generic s1=new Generic();
s1.show("林青霞");
s1.show(88);
    }
}
```

## 泛型接口

泛型接口的定义格式：

* 格式：修饰符 interface 接口名 <类型> { }
* 范例：public interface Generic `<T>`{ }

```java
//定义
public interface GenericInterface<T> {
    void show(T t);
}
//实现
public class Generic<T> implements GenericInterface<T>{
    @Override
    public void show(T t) {
System.out.println(t);
    }
}
```

## 类型通配符

为了表示各种泛型List的父类，可以使用类型通配符

* 类型通配符：**<?>**
* List<?>:表示元素类型未知的List,它的元素可以**匹配任何类型**
* 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中

如果说我们不希望List<?>是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限

* 类型通配符的上限：**<? extends 类型>**
* List<? entends Number>：它表示的类型是**Number或者其子类型**

也可以指定类型通配符的下限

* 类型通配符的上限：**<? super 类型>**
* List<? super Number>：它表示的类型是**Number或者其父类型**

```JAVA
//类型通配符:<?>
public class Generic{
    List<?> list1=new ArrayList<Object>();
    List<?> list2=new ArrayList<Number>();
    List<?> list3=new ArrayList<Integer>();

    List<? extends Number> list4=new ArrayList<Number>();
    List<? extends Number> list5=new ArrayList<Integer>();

    List<? super Number> list7=new ArrayList<Object>();
//    List<? super Number> list8=new ArrayList<Integer>();
}
```

## 可变参数

可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了

* 格式：修饰符 返回值类型 方法名(数据类型... 类型名){ }
* 范例：public static int sum(int... a){ }

```java
public class ArgsDemo1 {
    public static void main(String[] args) {
System.out.println(sum(10,12,13,14,13,15));
    }
    public static int sum(int... a){
int sum=0;
for(int i:a){
    sum+=i;
}
return sum;
    }
}
```

可变参数注意事项

* 这里的变量其实是一个数组
* 如果一个方法有多个参数，包含可变参数，**可变参数要放在最后**

## 可变参数的使用

Arrays工具类中有一个静态方法：

* public static `<T>`  List `<T>`   asList(T... a)：返回由指定数组支持的固定大小的列表
* 返回的集合不能做增删操作，可以做修改操作

List接口中有一个静态方法：

* public static `<E>` List of(E... element)：返回包含任意数量元素的不可变列表
* 返回的集合不能做增删改操作

Set接口中有一个静态方法：

* public static `<E>`  Set `<E>`  of(E... elements)：返回一个包含任意数量元素的不可变集合
* 在给元素的时候，不能给重复的元素
* 返回的集合不能做增删操作，没有修改的方法

```JAVA
public class ArgsDemo02 {
    public static void main(String[] args) {
//public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表
//数组大小固定，不能添加或删除
List<String>list= Arrays.asList("hello","world","java");
System.out.println(list);

//public static <E> List of(E... element)：返回包含任意数量元素的不可变列表
//数组大小固定，不能添加,删除或改变
List<String> list2 = List.of("hh", "ll", "gg");
//list.add("javaee");UnsupportedOperationExceptio
//list2.set(1,"ww");
System.out.println(list2);

//public static <E>  Set<E>  of(E... elements)：返回一个包含任意数量元素的不可变集合
//Set<String> set= Set.of("hello","world","java","hello");ImmutableCollections$SetN
Set<String> set= Set.of("hello","world","java");

    }
}
```

# Lambda表达式

表达式的标准格式

* 格式：（形式参数）->（代码块）
* 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，，留空即可
* ->：代表指向动作
* 代码块：表示具体要做的内容

Lambda表达式的使用前提

* 有一个接口
* 接口中有且仅有一个抽象方法

# Map

Map的3种遍历方式

键找值

    //获取通过keySet()获取key的

单列集合

```JAVA
    Set<String> keys = map.keySet();  
    Iterator<String> it = keys.iterator();  
    while(it.hasNext()){  
        String key = it.next();  
        System.out.println(map.get(key));  
    }
```

键值对

    //通过entrySet()获取键值对对象的单列集合
    Set<Map.Entry<String, String>> entries = map.entrySet();
    
    for (Map.Entry<String, String> entry : entries) {
        System.out.println(entry.getKey()+":"+entry.getValue());
    }

        keys.forEach(new Consumer `<String>`() {
            @Override
            public void accept(String s) {
                System.out.println(map.get(key));
            }
        });

lambda表达式遍历

```JAVA
        map.forEach(new BiConsumer<String, String>() {  
            @Override  
            public void accept(String key, String value) {  
                System.out.println(key+','+value);  
            }  
        });
```

### HashMap

重写HashCode()和equals()方法

```java
    @Override  
    public boolean equals(Object o) {  
        if (this == o) return true;  
        if (o == null || getClass() != o.getClass()) return false;  
        Student student = (Student) o;  
        return Objects.equals(name, student.name) && Objects.equals(age, student.age);  
    }  
    @Override  
    public int hashCode() {  
        return Objects.hash(name, age);  
    }  

```

### LinkedHashMap

有序，不重复，无索引

有序：保证存储顺序和取出顺序一致

### TreeMap

- 自然排序：对象类中

  - 实现接口Comparable
  - 重写方法compareTo()
- 比较器排序：传递接口

  - 传递接口Comparator
  - 重写方法compare()

### HashMap

无序、不重复、无索引

只用键计算hash值和比较；如果键比较后相同，新元素会将旧元素的值覆盖掉

1. hashmap底层是哈希表结构的
2. 依赖hashCode方法和equals方法保证键的唯一
3. 键存储的是自定义对象，需要重写hashCode和equals方法

   如果值存储自定义对象，不需要重写hashCode和equals方法

# Set

### HashSet

无序，不重复，无标号

通过**HashCode()**确定在表中位置，若null则添加，非null则调用**equal()**方法比较，不同则挂在旧元素后面，相同则舍去

### LinkedHashSet

在HashSet添加双链表结构，后一个元素在添加的同时会保存前一个元素的地址，前一个元素也会随之添加后一元素的地址值

### TreeSet

两种比较方式

默认/自然排序：javabean类实现Comparable接口指定比较规则

在比较对象的类中，实现**Comparable**接口，重写compareTo()方法

```JAVA
    @Override  
    public int compareTo(Student o) {  
        //指定排序规则  
        return 0;  
    }
```

比较器排序：创建TreeSet对象时，传递比较器**Comparator**指定规则

> 使用规则：默认使用第一种，如果第一种不能满足当前需求，就使用第二种，第二种会覆盖第一种默认

```java
        /*  
        需求：请自行选择比较器排序和自然排序两种方式：  
        需求：存入四个字符串：”c","ab","df","qwer"  
        按照长度排序，如果一样长则按照首字母排序  
         */  
        TreeSet<String> ts = new TreeSet<>(new Comparator<String>() {  
            //o1:当前要添加的元素  
            //o2:表示已经在红黑树存在的元素  
            @Override  
            public int compare(String o1, String o2) {  
                int i = o1.length() - o2.length();  
                //如果一样长则按照首字母排序  
                //不一样则按长度     
                return  i==0 ? o1.compareTo(o2) :i;  
            }  
        });
```

结构

- 自然排序：对象类中

  - 实现接口Comparable
  - 重写方法compareTo()
- 比较器排序：传递接口

  - 传递接口Comparator
  - 重写方法compare()

```java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * ArrayList
 */
public class ListDemo2 {

    public static void main(String[] args) {
// 0, 10, 10 + 10/2
ArrayList names = new ArrayList();
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily");
names.add("Lily"); // 11

// Arrays.ArrayList
//int[] nums = {10, 20, 30, 40, 50};
Integer[] nums = {10, 20, 30, 40, 50};
List numList = Arrays.asList(nums);
System.out.println(numList);
    }

}
```

# Queue

Queue 用于模拟队列，他是一种先进先出（FIFO）的容器。

| 方法                        | 说明                                                     |
| --------------------------- | -------------------------------------------------------- |
| `boolean add(Object e)`   | 将元素加入队尾；                                         |
| `Object element()`        | 获取队列头部的元素，但不删除元素；                       |
| `boolean offer(Object e)` | 将元素加入队列尾部，当使用有容量限制的队列时此方法更好； |
| `Object peek()`           | 获取队列头部，但不删除元素，队列为空时返回 null；        |
| `Object poll()`           | 获取队列头部，删除元素，队列为空时返回 null；            |
| `object remove()`         | 获取队列头部，删除元素；                                 |

```java
Queue queue = new ArrayDeque();
queue.offer("Mary");
queue.offer("Lily");
queue.offer("Tony");
queue.offer("John");
queue.offer("Lucy");
System.out.println(queue);

// 返回头部(不删),队列为空时返回null.
System.out.println(queue.peek());
System.out.println(queue.peek());
System.out.println(queue);

// 返回头部(删除),队列为空时返回null.
while (queue.size() > 0) {
    System.out.println(queue.poll());
}
System.out.println(queue);
    }
```

> 经常看到一个现象，接口的引用指向它实现类的一个对象
>
> 例如：List list = new [ArrayList](https://so.csdn.net/so/search?q=ArrayList&spm=1001.2101.3001.7020) `<String>`();
>
> ### 为什么要这样用，而不使用：ArrayList list = new ArrayList `<String>`();   这样做的好处是什么
>
> 这其实是 Java 中[多态](https://so.csdn.net/so/search?q=%E5%A4%9A%E6%80%81&spm=1001.2101.3001.7020)的一种表现
>
> 接口的实现类可以有很多个，如 [LinkedList](https://so.csdn.net/so/search?q=LinkedList&spm=1001.2101.3001.7020) 或者 Vector 等等，如果使用这种方式，List list = new ArrayList `<String>`();  以后不想用 ArrayList 了，直接改为你想用的实现类，如 List list = new LinkedList `<String>`();  这样，虽然修改了实现类，但相关 list 调用方法的代码是不用修改的；如果是 ArrayList list = new ArrayList `<String>`();这种写法，那就有可能要修改非常多代码了，因为，原本 list 调用了 ArrayList 中的方法来实现某个功能，再修改实现类过后，list 原本调用的方法在 LinkedList 中不存在，则还要修改对应调用的方法；因此：
>
> 两种方式其实都能实现同一种效果，只是接口的引用指向实现[类对象](https://so.csdn.net/so/search?q=%E7%B1%BB%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020)这一方法，是用接口来规范了实现的方法，这样子写的化就很清楚的知道哪些方法有，哪些方法没有。
>
> 这就是一种设计规范，如果按照这种设计规范来写，就可以免去在修改实现的对象吼调用方法不存在的情况。
>
> 这样写的好处是便于程序代码的重构. 这就是面向接口编程的好处
>
> **接口指向实现类，便于之后修改指向，实现多态**

## Deque 双端队列

Deque 代表双端队列，它允许你从两端来操作队列中的元素，并支持入栈及出栈操作。

Deque 在 Queue 的基础上，增加了两类方法：

```java
//双端队列方法
boolean offerFirst(Object e),
boolean offerLast(Object e)
```

## Properties

属性文件：属性名与属性值的文件、如".ini"、".properties"

```java
#db config
username=mowcoder
password=123456
```

```java

import java.io.IOException;
import java.util.Properties;

/**
 * Properties
 */
public class MapDemo3 {

    public static void main(String[] args) {
Properties properties = new Properties();
try {
    // 相对路径: 以编译后的项目的根目录为起点.
    properties.load(MapDemo3.class.getClassLoader()
    .getResourceAsStream("resources/db.properties"));
    String s1 = properties.getProperty("username");
    String s2 = properties.getProperty("password");
    System.out.println(s1 + ", " + s2);
} catch (IOException e) {
    throw new RuntimeException("加载资源文件失败!", e);
}
    }

```

## hashCode()

将任意长度的消息压缩成固定长度的消息的算法，其输出就是散列值

1. Object类中定义的hashCode()方法，就是用于返回该对象的散列值；
2. Object类对此方法采用默认实现，即返回该对象在内存中的物理地址；
3. 子类通常需要重写hashCode()方法，根据封装数据，计算出合理的散列值。

散列表

1. Hashtable，译作散列表，其内部利用散列值决定元素存放的位置；
2. HashMap，比Hashtable更新的API，存储原理一致；
3. HashSet，采用HashMap实现，因此存储原理也与Hashtable一致

hashCode() & equals()

1. 散列值可以是任何整数，包括整数或负数；
2. hashCode()、equals()的定义必须兼容，规则是：
   如果两个对象通过equals()比较返回ture，这两个对象的hashCode()值也必须相同

# File

## File概述和构造方法

File：它是文件和目录路径的抽象表示

* 文件和目录可以通过File封装成对象的
* 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，将来要通过具体的操作把这个路径的类容转换为具体存在

```java
    public static void main(String[] args) {
//1.File(String pathname)：通过将给定的路径名的字符串转换成一个抽象路径名创建一个新的 File实例。
File f1=new File("D:/1");
   
//2.File(String parent, String child)：创建从父路径名的字符串和一个孩子的一个新的 File实例文件
File f2=new File("D:","1");

//3.File(File parent, String child)：创建从一个家长的抽象路径名和一个孩子的路径字符串的新 File实例。
File f3=new File(f1,"1.txt");
    }
```

## File类创建功能

```java
//    boolean createNewFile()
//    自动创建一个新的空文件命名的抽象路径名的当且仅当该文件不存在。
//    boolean mkdir()
//    创建该目录下的抽象路径名命名
//    boolean mkdirs()
//    创建该目录下的抽象路径名命名，包括任何必要的但不存在父目录
public static void main(String[] args) throws IOException {
    //1.创建文件
    File f1=new File("D:/2/11.txt");
    System.out.println(f1.createNewFile());
    //2.创建目录,当父目录存在时
    File f2=new File("D:/1/1");
    f2.mkdir();
    //3.创建多级目录
    f2.mkdirs();
    //4.删除目录或文件
    f2.delete();
}
```

## File类判断和获取功能

```java
public static void main(String[] args) {
    File f1=new File("D:/1");
    //测试此抽象路径名表示的File是否为目录
    System.out.println(f1.isDirectory());
    //测试是否为文件
    System.out.println(f1.isFile());
    //测试File是否存在
    System.out.println(f1.exists());
    //返回绝对路径抽象字符串
    System.out.println(f1.getAbsolutePath());
    //返回此抽象名表示的文件或目录名称
    System.out.println(f1.getName());
    //返回抽象路径名表示的目录中的 文件和目录 的名称字符串数组
    String[] list = f1.list();
    for(String str:list){
System.out.println(str);
    }
    //返回抽象路径名表示的目录中的 文件和目录 的File对象数组
    File[] files = f1.listFiles();
    for(File file:files){
System.out.println(file);
    }
}
```

## 文件过滤

```java
public class file {
    public static void main(String[] args) {
File dir=new File("C:/1");//文件夹
File[] files=dir.listFiles();//文件列表
//获取过滤后的文件列表
files=dir.listFiles(new FileFilter() {
    @Override//过滤
    public boolean accept(File pathname) {
if(pathname.getName().endsWith(".txt")){
    return true;
}
return false;
    }
});

files=dir.listFiles(new FilenameFilter() {
    @Override
    public boolean accept(File dir, String name) {
System.out.println(dir.getName()+","+name);//文件夹名，与文件名
return false;
    }
});
System.out.println(Arrays.toString(files));
    }
}
```

## 遍历文件

```java
import java.io.File;
public class file3 {
    public static void main(String[] args) {
printFile("D:/1",0);
    }

    /*
     * alpha
     *   a
     *      - x.png
     *      - y.png
     *   - 1.txt
     *   - 2.txt
     */
    public static void printFile(String filePath, int depth) {
File file = new File(filePath);

if (!file.exists()) {
    throw new IllegalArgumentException("文件不存在!");
}

// 打印空格
for (int i = 0; i < depth; i++) {
    System.out.print("  ");
}
// 打印名字
if (file.isFile()) {
    System.out.print(" - ");
}
System.out.println(file.getName());
// 目录递归
if (file.isDirectory()) {
    File[] files = file.listFiles();
    for (File f : files) {
printFile(f.getPath(), depth + 1);
    }
}
    }
}
```

# IO流

字节流

* FileInputStream
* FileOutputStream

转换流

* OutputStreamWriter
* InputStreamReader

字符流

* FileWriter
* FileReader

## 字节流

字节流抽象基类

* InputStream：这个抽象类是表示字节输入流的所有类的超类
* OutputStream：这个抽象类是表示字节输出流的所有类的超类
* 子类名特点：子类名称都是以其父类名作为子类名的后缀

FileOutputStream：文件输出流用于将数据写入File

```java
//1.创建字节输出流对象
FileOutputStream os=new FileOutputStream("D:1.txt");
/*
    做了三件事情：
    1：调用系统功能创建文件
    2：创建了字节输出流对象
    3：让字节输出流指向创建好的对象
 */
//void WRIBE(INT B):将只当的字节写入此文件输出流
//2.写入数据
os.write(97);
//void close(),关闭此文件输出流并释放与此流相关联的任何系统资源
os.close();
```

写入方式

```java
FileOutputStream os=new FileOutputStream(new File("D:/1/2.txt"));
byte[] bys={97,97,97,98};
byte[] byss="abcdeee".getBytes();
//1.一次一字节
os.write(97);
//2.一次一数组
os.write(bys);
os.write(byss);
//3.void write(byte[] b,int off,int len);将len字节从偏移量off开始写入输出流
os.write(bys,3,1);
```

追加写入

```java
//追加写入，再后面加true
FileOutputStream fos=new FileOutputStream("D:/1/File_append.txt",true);
for (int i = 0; i < 10; i++) {
    fos.write("hellow\r\n".getBytes());
}
fos.close();
```

异常处理

```JAVA
FileOutputStream fos=null;
try {
    fos=new FileOutputStream("D:/1/3.txt");
    fos.write("hellw".getBytes());
} catch (IOException e) {
    e.printStackTrace();
}finally{
    if(fos!=null){
try{
    fos.close();
} catch (IOException e) {
    e.printStackTrace();
}
    }
}
```

字节流读

```java
//1.创建字节流输入对象
FileInputStream fio=new FileInputStream("D:/1/2.txt");
//2,调用字节流对象的读数据方法
// 第一次读取数据
int one=fio.read();
System.out.println(one);
System.out.println((char)one);
//第二次读取数据
int two=fio.read();
System.out.println((char)two);
//若读取到文件末尾，返回-1
int again=fio.read();
while(again!=-1){
    System.out.print((char)again);
    again=fio.read();
}//优化上面代码
while((again=fio.read())!=-1){
    System.out.println((char)again);
}
//释放资源
fio.close();
```

利用数组读取

```JAVA
FileInputStream fis=new FileInputStream("D:/1/2.txt");
byte[] bys = new byte[128];
int len;
while ((len=fis.read(bys))!=-1){
    System.out.println(new String(bys,0,len));
}
```

字节流复制文件夹

```java
private static void copydir(File src, File dest) throws IOException {

    //递归
    if(src.isFile()){
FileInputStream fis = new FileInputStream(src);
FileOutputStream fos = new FileOutputStream(dest);
byte[] bytes = new byte[1024];
int len;
while((len=fis.read(bytes))!=-1){
    fos.write(bytes,0,len);
}
fos.close();
fis.close();
    }else{//源是文件夹

//在目标处创建文件夹
dest.mkdirs();

if(src!=null){
    //遍历源文件夹
    File[] files = src.listFiles();
    for (File file : files) {

File sonfile = new File(dest, file.getName());
copydir(file,sonfile);
    }
}
    }
}
```

## 字节缓冲流

构造方法

* 字节缓冲输出流：BuferedOutputStram(OutputStream out)
* 字节缓冲输入流：BufferedInputStream(InputStream in)

```java
BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("D:/1/4.txt"));
bos.write("hello\r\n".getBytes());
bos.close();
//字节缓冲罐输入流
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("D:/1/4.txt"));
//一次读取一个字节数据
int by;
while((by=bis.read())!=-1){
    System.out.print((char)by);
}
//一次读一个数组
byte[] bys=new byte[128];
int len;
while ((len=bis.read(bys))!=-1){
    System.out.print(new String(bys,0,len));
}
bis.close();
```

字节缓冲流-复制视频

```java
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("D:/1/hh.mp4"));
BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("D:/1/gg.mp4"));
byte[] bys = new byte[128];
int len;
while((len=bis.read(bys))!=-1){
    bos.write(bys,0,len);
}
bis.close();
bos.close();
```

```java
String s="中国";
byte[] bys=s.getBytes();
bys=s.getBytes("UTF-8");
bys=s.getBytes("GBK");
String ss=new String(bys,"GBK");
System.out.println(ss);
```

## 转换流

被淘汰

```java
OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream("D:/1/2233.txt"),"GBK");
osw.write("中国");
osw.close();
```

```java
InputStreamReader isr=new InputStreamReader(new FileInputStream("D:/1/2233.txt"),"GBK");
int ch;
while((ch=isr.read())!=-1){
    System.out.print((char)ch);
}
isr.close();
```

替代方案 `Charset.forName("GBK")`

```java
FileReader r = new FileReader("D:\\aaa\\1.txt", Charset.forName("GBK"));
char[] chars=new char[30];
int len;
while ((len=r.read(chars)) != -1)
    System.out.print(new String(chars,0,len));
r.close();
```

## 字符流

写入文件

```java
    FileWriter fw=new FileWriter("\\1.txt");
    fw.write(97);
    fw.flush();//刷新流
    char[] cbuf={'1','2','3'};
    fw.write(cbuf);
    //3.write(char[] cbuf,int off,int len):写入字符数组的一部分
    fw.write(cbuf,1,2);
    fw.write("1234",true);
    //5.(String s,int off,int len):写入字符串一部分
    fw.write("abcde",0,3);
```

读文件-无参read()

```java
	//创建对象并关联本地文件
	FileReader fr = new FileReader("1.txt");
	int ch;
	while((ch = fr.read()) != -1)
	    System.out.print((char) ch);
	fr.close();
```

读-有参read()

```java
    FileReader fr = new FileReader("1.txt");
    char[] chars=new char[2];
    int len;
	//read(chars):读取数据，解码，强转三步合并了，把强转之后的字符放到数组当中
    while ((len=fr.read(chars)) != -1)
System.out.print(new String(chars,0,len));
    fr.close();
```

## 字符缓冲流

* BufferedWriter：将文本写入字符输出流，缓冲字符，以提供高效写入，可以指定缓冲区大小，或者可以接受默认大小；
* BufferedReader：从字符输入流读取文本，缓冲字符，以提供高效读取。

构造方法

* BufferedWriter(Writer out)
* BufferedReader(Reader in)

```java
    FileWriter fw = new FileWriter("D:/1/1_11.txt"，true);
    BufferedWriter bw=new BufferedWriter(fw);
    bw.write("生非易事，死亦何苦");
    FileReader fr=new FileReader("D:/1/1.txt");
    BufferedReader br=new BufferedReader(fr);
    int a;
    while((a=br.read())!=-1){
System.out.println((char)a);
    }
```

字符缓冲流复制文件

```java
    BufferedReader br=new BufferedReader(new FileReader("D:/1/wo.txt"));
    BufferedWriter bw=new BufferedWriter(new FileWriter("D:/1/ta.txt"));
    int len;
    char[] chs=new char[1024];
    while ((len=br.read(chs))!=-1){
bw.write(chs,0,len);
    }
    br.close();
    bw.close();
```

字符缓冲流特有功能

BufferedWriter：

* void newLine():写一行行分隔符，行分隔符字符串由系统属性定义

BufferedReader：

* public String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符（换行符），如果流的结尾已经到达，则为null

```java
BufferedWriter bw=new BufferedWriter(new FileWriter("D:/1/2.txt"));
    for (int i = 0; i < 10; i++) {
bw.write("hello"+i);
bw.newLine();
    }
    bw.close();
    BufferedReader br=new BufferedReader(new FileReader("D:/1/2.txt"));
    String line = br.readLine();
    System.out.println(line);
```

特有功能复制文件

```java
public static void main(String[] args) throws IOException {
    BufferedReader br=new BufferedReader(new FileReader("D:/1/wo.txt"));
    BufferedWriter bw=new BufferedWriter(new FileWriter("D:/1/ta.txt"));
    String line;
    while((line=br.readLine())!=null){
bw.write(line);
bw.newLine();
    }
    bw.close();
    br.close();
}
```

字符流-集合到文件

```java
/**
 * 需求：把Arraylist集合中的字符串数据写入到文本文件，要求每一个字符串元素作为文件中的一行数据
 */
public static void main(String[] args) throws IOException {
    ArrayList<String> arrayList=new ArrayList<>();
    arrayList.add("第一个");
    arrayList.add("第二个");
    BufferedWriter bw=new BufferedWriter(new FileWriter("D:/1/9.txt"));
    for(String s:arrayList){
bw.write(s);
bw.newLine();
    }
    bw.close();
}
```

字符流-文件到集合

```java
    BufferedReader br=new BufferedReader(new FileReader("D:/1/9.txt"));
    ArrayList<String> array=new ArrayList<>();
    String len;
    while((len=br.readLine())!=null){
array.add(len);
    }
}
```

```java
public static void main(String[] args) throws IOException {
    BufferedReader br=new BufferedReader(new FileReader("D:/1/10.txt"));
    ArrayList<Student> array=new ArrayList<>();
    String line;
    while((line=br.readLine())!=null){
String[] strArray=line.split(",");
Student s=new Student(strArray[0],strArray[1],Integer.parseInt(strArray[2]),strArray[3]);
array.add(s);
    }
    br.close();
    System.out.println(array);
}
```

## 序列化流

对象序列化流：

* ObjectOutputStream(OutputStream out)
* void Write(Object obj)

对象反序列化流

* ObjectInputStream(InputStream in)
* Object readObject()

> 一个对象要想被序列化，该对象所属的类必须实现Serializable接口(标记型接口)

序列化流

```java
ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("D:/1/Obj.txt"));
Student s1=new Student("我系猪",30);
oos.writeObject(s1)
oos.close();    
```

反序列化流

```java
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("a.txt"));
Student o = (Student) ois.readObject();
ois.close();
```

类版本-serialVersionUID

```JAVA
public static final long serialVersionUID=42L;
```

> idea::File > Settings > Editor > Inspections > JVM languages

指定不序列化-transient

```java
private transient int age;
```

## 标准流

System类中有两个静态的成员变量：

* InputSteam in：标准输入流
* PrintStream out：标准输出流

```java
////1.标准输入流
//InputStream is=System.in;
//int by;
//while((by=is.read())!=-1){
//    System.out.println((char)by);
//}
////2.字节流转换为字符流
//InputStreamReader isr=new InputStreamReader(is);
////3.一次读取一行数据的方法是字符缓冲流的特有方法
//BufferedReader bis=new BufferedReader(isr);
//三合一
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
System.out.println("请输入一个整数");
//字符串转换
int i=Integer.parseInt(br.readLine());
//经典
Scanner sc=new Scanner(System.in);

//输出流
PrintStream ps=System.out;
ps.println("hello");
ps.print(100);
System.out.println(122);
```

## 打印流

字节打印流：PrintStream(String fileName)

```java
PrintStream ps=new PrintStream("D:/1/1.txt");
ps.write(97);//a	转码
ps.print(97);//97	原样输出
```

字符打印流：PrintWriter(String fileName)

```java
PrintWriter pw=new PrintWriter("D:/1/1.txt");
pw.write("hello");
pw.flush();
//PrintWriter(Writer out,boolean autoFlush)
PrintWriter pww=new PrintWriter(new FileWriter("D:/1/1.txt"),true);
pww.println("hello");
```

打印流-复制文件

```java
//创建字符输入流对象
BufferedReader br=new BufferedReader(new FileReader("D:/1/1.txt"));
//创建字符输出流对象
PrintWriter pw=new PrintWriter(new FileWriter("D:/1/2.txt"),true);
//读数据，复制文件
char[] chs=new char[1024];
int len;
while((len=br.read(chs))!=-1){
	pw.print(chs);
}
```

## 解压缩流

```java
    File src = new File("1.zip");
    File dest = new File("1");
    ZipInputStream zip = new ZipInputStream(new FileInputStream(src));
    ZipEntry entry;
    while ((entry = zip.getNextEntry()) != null) {
        System.out.println(entry);
        if(entry.isDirectory()){
            File file = new File(dest, entry.toString());
            file.mkdirs();
        }else{
            FileOutputStream fos = new FileOutputStream(new File(dest, entry.toString()));
            int b;
            while ((b=zip.read())!=-1){
                fos.write(b);
            }
            fos.close();
            //表示压缩包中的一个文件处理完毕了
            zip.closeEntry();
        }
    }
    zip.close();
```

## Properties

概述：

* 是一个Mao体系的集合类
* Propertise可以保存到流中或从流中加载

Properties作为集合的特有方法：

|                   方法名                   |                               说明                               |
| :-----------------------------------------: | :--------------------------------------------------------------: |
| Object setProperty(String key,String value) |    设置集合的键和值，都是String类型，底层调用Hashtable方法put    |
|        Sting getProperly(String key)        |                 使用此属性列表中指定的键搜索属性                 |
|   Set `<String>` stringPropertyNames()   | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 |

## Properties和IO流结合的方法

| 方法名                                       | 说明                                                                                                |
| -------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| void load(InputStream inStream)              | 从输入字节流读取属性列表(键和元素对)                                                                |
| void load(Reader reader)                     | 从输入字符流读取属性列表                                                                            |
| void store(OutputStream out,String comments) | 将此属性列表（键和元素对）写入此Properties表中，以适合使用load(InputStream)方法的格式写入输出字符流 |
| void store(Writer writer,String comments)    | 将此属性列表（键和元素对）写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流      |

```java
public static void main(String[] args) throws IOException {
//集合中的数据保存到文件
myStore();
//文件中的数据加载到集合
myLoad();
    }
private static void myLoad() throws IOException {
Properties prop=new Properties();
FileReader fr=new FileReader("D:/1/1.txt");
//void load(Reader reader)
prop.load(fr);
fr.close();
System.out.println(prop);
    }
private static void myStore() throws IOException {
Properties prop=new Properties();

prop.setProperty("001","白莽");
prop.setProperty("002","殷夫");
prop.setProperty("001","逐原");
//void store(Writer writer,String comments)
FileWriter fw=new FileWriter("D:/1/1.txt");
//将集合数据存储到文件
prop.store(fw,null);
fw.close();
```

# 多线程

实现方式

1. 继承 `Thread类`的方式实现
2. 实现 `Runnable接口`方式进行实现
3. 利用 `Callable接口`和 `Future接口`方式实现

## 1.继承Thread类

```java
public class ThreadDemo {
    public static void main(String[] args) {
MyThread s1=new MyThread("第一");
MyThread s2=new MyThread("第二");
//直接调用封装好的方法，未启动线程
//s1.run();
//s2.run();
//启动线程；然后由JVM调用此线程的run()方法
s1.start();
s2.start();
    }
}
class MyThread extends Thread{
    MyThread(String name){
		super(name)
    }
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName()+i);
        };
    }
}
```

## 2.实现Runnable接口

实现Runnable接口

1. 定义一个实现类实现Runnable接口
2. 在实现类中重写run()方法
3. 创建实现类对象
4. 创建Thread类的对象，把实现类对象作为构造方法的参数
5. 启动线程

```java
public static void main(String[] args) {
    MyRunnable my=new MyRunnable();
    Thread t1=new Thread(my);
    Thread t2=new Thread(my);
    t1.start();
    t2.start();
}
```

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
		for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
		}
    }
}
```

相比继承Thread类，实现Runnable接口的好处

* 避免了Java单继承的局限性
* 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想

## 3.第三种实现方式

可以获取到多线程的 `运行结果`

1. 创建一个类MyCallable实现 `Callable接口`
2. 重写call（有返回值，表示多线程运行的结果)
3. 创建MyCallable的对象（表示多线程要执行的任务）
4. 创建 `FutureTask`的对象（作为管理多线程运行的结果）

```JAVA
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //任务
        MyCallable mc = new MyCallable();
        //管理任务运行结果
        FutureTask<Integer> ft = new FutureTask<>(mc);
        //创建线程对象
        Thread t1= new Thread(ft);
        //启动线程
        t1.start();

        //获取结果
        Integer result = ft.get();
        System.out.println(result);
    }
```

```JAVA
public class MyCallable implements Callable<Integer> {
    //重写call，返回值表示多线程运行的结果
    @Override
    public Integer call() throws Exception {
        int sum=0;
        for (int i = 1; i <= 100; i++)
            sum+=i;
        return sum;
    }
}
```

## 常见的成员方法

| 方法名称                          | 说明                                     |
| :-------------------------------- | :--------------------------------------- |
| String getName()                  | 返回此线程名称                           |
| void setName(String name)         | 设置线程的名称（构造方法也可以）设置名字 |
| `static` Thread currentThread() | 获取当前线程的对象                       |
| final getPriority()               | 返回此线程的优先级                       |
| setPriority(int newPriority)      | 设置线程优先级                           |
| final void setDaemon(boolean on)  | 设置为守护线程                           |
| public static void yield()        | 礼让线程                                 |
| public static void join()         | 插队线程                                 |
| `static` void sleep(long time)  | 使线程休眠                               |

调用父类Thread构造方法设置名称

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread s1=new MyThread();
        //有参构造方法设置名称
        MyThread s3=new MyThread("线程333")
    }
}

class MyThread extends Thread{
    public MyThread(){}
    public MyThread(String name){
		super(name);
    }
}
```

sleep()：使当前执行的线程停留指定的毫秒数

```java
public class ThreadSleep extends Thread {
    @Override
    public void run() {
		for (int i = 0; i < 10; i++) {
    		System.out.println(getName()+":"+i);
            try{
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
             	}
		}
    }
}
```

Daemon

```java
//void Daemon(boolean on)：将此线程标记为守护线程，当运行的线程都是守护线程时，java虚拟机将退出
public class ThreadDaemonDemo {
    public static void main(String[] args) {
        ThreadDaemon td1=new ThreadDaemon("张飞");
        //设置主线程为刘备
        Thread.currentThread().setName("刘备");
        td1.start();
        //守护线程
        td1.setDaemon(true);
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
```

## 同步代码块

锁多条语句操作共享数据，可以使用同步代码块实现

格式

```JAVA
sychronized(任意对象){
    多条语句操作共享数据的代码
}
```

> 当某a线程进入【加锁的代码块】，代码块加锁，只有此a线程拥有钥匙可以解锁，其他线程不在拥有执行权，直到此a线程执行完【加锁的代码块】，释放其钥匙

```java
public class SellTiket implements Runnable{
    private int tickets=100;
    private Object obj=new Object();
    @Override
    public void run() {
        while(true) {
            synchronized (obj) {
                if (tickets > 0) {
                    tickets--;
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在出售" + tickets + "张票");
                }
            }
        }
    }
}
```

## 同步方法

* 同步方法格式：修饰符 synchronized 返回值类型 方法名(方法参数){}
  同步方法锁的对象是this
* 同步静态方法：修饰符 static synchronized 返回值类型 方法名(方法参数){}

## 线程安全的类

StringBuffer

* 线程安全，可变的字符序列
* 从版本5开始，被StirngBuider替代，通常使用StringBudier类，因为他支持所有相同的操作，但他更快，因为他不执行同步

Vector

* 如不需要线程安全，建议使用ArrayList代替Vector

Hashtable

* 该类实现一个哈希表
* 如不需要线程安全，建议使用HashMap代替Hashtable

## lock锁

lock中提供了方法

* viod lock();获得锁
* void unlock();释放锁

lock是接口不能直接实例化，可以采用他的实现类Reemtrantlock来实例化

```java
public class MyThread extends Thread{
    static int i=0;
    static Lock lock =new ReentrantLock();//同一个锁对象
    @Override
    public void run(){
        while(true){
            lock.lock();//锁
            try {
                if(i==100)
                    break;
                else
                    Thread.sleep(10);
                i++;
                System.out.println(i);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.unlock();//开
            }
        }
    }

}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    Thread t1 = new Thread(mt);
    Thread t2 = new Thread(mt);
    t1.start();
    t2.start();
}
```

## 生产者消费者

生产者消费者模式是一个十分经典的多线程协作模式
主要包含了两类线程：

* 一类是生产者线程用于生产数据
* 一类是消费者线程用于消费数据

生产者生产数据之后直接放置在共享数据区

Object类的等待和唤醒方法

|      方法名      | 说明                                                                      |
| :--------------: | ------------------------------------------------------------------------- |
|   void wait()   | 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法 |
|  void notify()  | 唤醒正在等待对象监视器的单个线程                                          |
| viod notifyAll() | 唤醒正在等待对象监视器的所有进程                                          |

## 阻塞队列

ArrayBlockingQueue：底层是数组，有界

LinkedBlockingQueue：底层是链表，无界；但不是真正的无界，最大为int的最大值

## 线程池

java提供的：

* Executors.newFixedThreadPool()：创建一个没有上限的线程池
  Executors.newFixedThreadPool(int nThread)：创建有上限的线程
* submit(Runnable r)：提交任务

自定义线程池

| ThreadPoolExecutor                                  |
| --------------------------------------------------- |
| 核心线程数量(>0)                                    |
| 最大线程的数量(>=核心线程池数量)                    |
| 空闲线程最大存活时间 —— 值(>0),单位(TimeUnit指定) |
| 任务队列(≠null)                                    |
| 创建线程工厂(≠null)                                |
| 任务的拒绝策略(≠null)                              |

# 网络编程

## InetAddress

```java
{
    //获取主机IP地址，通过主机名或IP地址
    InetAddress address= InetAddress.getByName("Qiu");
    //获取此IP地址主机名
    String name= address.getHostName();
    //返回IP地址的文本字符串
    String ip=address.getHostAddress();
  
}
```

## UDP发送数据

步骤

1. 创建发送端的Socket对象（DatagramSocket）
2. 创建数据并打包
3. 调用DatagramSocket对象的方法发送数据
4. 关闭发送端

```java
    //创捷套接字对象
    DatagramSocket ds=new DatagramSocket();
    byte[] bys="hello,UDP,i com!".getBytes();
    int length=bys.length;
    InetAddress address=InetAddress.getByName("192.168.1.105");
    int port=10086;
    DatagramPacket dp=new DatagramPacket(bys,bys.length,address,port);
	//字节数组，数据长，目的地址，目的端口
    //调用DatagramSocket对象的方法发送数据
    ds.send(dp);
    ds.close();
```

## UDP接受数据

步骤

1. 创建接收端的Socket对象(DatagramSocket)
2. 创建一个数据包，用于接受数据：DatagramPacket(bys,bys.length)
3. 调用DatagramSocket对象的方法接受数据receive(byte[])
4. 解析数据包，并把数据在控制台显示getDate()
5. 关闭接收端

```java
    //构造套接字将其绑定到本地主机上的指定端口
    DatagramSocket ds=new DatagramSocket(10086);
    //创建一个数据包，用于存储内容
    byte[] bys=new byte[128];
    DatagramPacket dp=new DatagramPacket(bys,bys.length);
    //调用DatagramPacket对象的方法接受数据
    ds.receive(dp);
    //解析数据包，并把数据在控制台显示
    //byte[] getData() 返回数据缓冲区
    System.out.println("数据是："+new String(dp.getData(),0,dp.getLength()));
    ds.close();
```

## UDP单播、组播、广播

组播地址：224.0.0.0 ~ 239.255.255.255
	其中224.0.0.0 ~ 224.0.0.255 为预留的组播地址

广播地址:255.255.255.255

send.class

```JAVA
//创建MulticastSocket对象
MulticastSocket ms=new MulticastSocket();
//创建数据包
String s="I am sender,你好吗?";
byte[] bytes = s.getBytes();
InetAddress address = InetAddress.getByName("224.0.0.1");
int port =1000;
DatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length, address, port);
//发送
ms.send(datagramPacket);
ms.close();
```

recive.class

## TCP发送数据

步骤

1. 创建客户端的Socket对象Sock(String host,imt port)
2. 获取输出流，写数据getOutputStream()
3. 释放资源

```java
//创建流套接字并链接IP地址和端口
//Socket s=new Socket(InetAddress.getByName("192.168.1.105"),10086);
Socket s=new Socket("192.168.1.105",10086);
//获取输出流，写数据
OutputStream os=s.getOutputStream();
os.write("hello,tcp,我来了".getBytes());
s.close();
```

## TCP接受数据

步骤

1. 创建客户端的Socket对象Sock(String host,imt port)
2. 获取输入流，读数据并将其显示在控制台
3. 释放资源

```java
	//创建服务端Socket对象,并绑定到指定端口的服务器套接字
    ServerSocket ss=new ServerSocket(10086);
    //监听连接到此套接字并接受他
    Socket s=ss.accept();
    InputStream is=s.getInputStream();
    byte[] bys=new byte[1024];
    int len= is.read(bys);
    System.out.println("数据是："+new String(bys,0,len));
    ss.close();
```

## TCP客户端与服务器

```java
   //发送数据
    Socket s=new Socket("192.168.1.105",10086);//创建套接字
    OutputStream os=s.getOutputStream();//获取输出流
    os.write("hello,wolaile".getBytes());

    //接受服务器反馈
    InputStream is=s.getInputStream();//获取输入流
    byte[] bys=new byte[1024];
    int len=is.read(bys);
    System.out.println("客户端："+new String(bys,0,len));
    s.close();
```

```java
	//接受数据
    ServerSocket ss=new ServerSocket(10086);//端口
    Socket s=ss.accept();//监听端口，形成虚拟链路的一端
    InputStream is=s.getInputStream();//获取输入流
    byte[] bys =new byte[1024];
    int len=is.read(bys);
    System.out.println("服务器："+new String(bys,0,len));
    //回复消息
    OutputStream os=s.getOutputStream();
    os.write("数据已经收到".getBytes());
```

## 综合练习

### 1.多发多收

Client：多次发送数据
Server：多次接受数据，并打印

Client

```java
//1. 创建Socket对象并连接服务端
Socket socket=new Socket("127.0.0.1",10000);
//2. 写出数据
Scanner sc =new Scanner(System.in);
OutputStream os = socket.getOutputStream();
while (true) {
    System.out.println("请输入您要发送的信息");
    String str = sc.nextLine();
    if("886".equals(str))
        break;
    os.write(str.getBytes());
}
//3.释放资源
socket.close();
```

Server

```java
//1. 创建对象绑定10000端口
ServerSocket ss = new ServerSocket(10000);
//2. 等待客户端连接
Socket socket = ss.accept();
//3. 读取数据
InputStreamReader isr = new InputStreamReader(socket.getInputStream());
int b;
while ((b = isr.read()) != -1) {//客户端关闭通道，返回-1
    System.out.print((char) b);
}
//4. 释放资源
socket.close();//关连接通道
ss.close();//关服务器
```

### 2.接受和反馈

Client：发送数据，接受服务端反馈的消息并打印
Server：接受数据并打印，再给客户端反馈消息

Client

```java
//1. 创建Socket对象并连接服务端
Socket socket=new Socket("127.0.0.1",10000);
//2. 写出数据
OutputStream os = socket.getOutputStream();
os.write("见到你很高兴!".getBytes());
//*****未关通道，服务器无法到结束标记，服务器卡死，无法回应
//写出一个结束标记,不能直接写-1
socket.shutdownOutput();
//3.接收服务端回写的数据
InputStreamReader isr = new InputStreamReader(socket.getInputStream());
int c;
while ((c=isr.read())!=-1){
    System.out.print((char)c);
}
//3.释放资源
socket.close();
```

> 发送数据不关流的话需要写出一个 `结束标记`，让接收方知道数据传输结束，避免一直read等待

Server

```java
//1. 创建对象绑定10000端口
ServerSocket ss = new ServerSocket(10000);
//2. 等待客户端连接
Socket socket = ss.accept();
//3. 读取数据
InputStreamReader isr = new InputStreamReader(socket.getInputStream());
int c;
/*
read方法会从通道中读取数据
但是需要结束标记，此处循环才回停止
否则，程序就会一致停在read这里，等待读取下面的数据
 */
while ((c=isr.read())!=-1){//*****客户端未关闭通道，无法读到结束标记，需要客户端手动发送
    System.out.print((char)c);
}
//4.回写数据
OutputStream os = socket.getOutputStream();
os.write("有多高兴?".getBytes());
//释放资源
socket.close();//关连接
ss.close();//关服务器
```

### 3.上传文件

Client:将本地文件上传到服务器。接受服务器的反馈
Server:接受客户端上传的文件，上传完毕之后给出反馈

Client

```JAVA
//1. 创建Socket对象并连接服务端
Socket socket=new Socket("127.0.0.1",10000);
//2.读取本地文件中的数据，并写到服务器当中
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("src.txt"));
BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());
byte[] bytes = new byte[1024];
int len;
while((len=bis.read(bytes))!=-1){
    bos.write(bytes,0,len);//写入缓冲区
    bos.flush();//刷出去
}
socket.shutdownOutput();
//3.接收服务端回写的数据
System.out.println(new BufferedReader(new InputStreamReader(socket.getInputStream())).readLine());
//释放资源
bis.close();
socket.close();
```

Server

```java
//1. 创建对象绑定10000端口
ServerSocket ss = new ServerSocket(10000);
//2. 等待客户端连接
Socket socket = ss.accept();
//3. 读取数据,并保存到本地文件中
BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("dst.txt"));
byte[] bytes = new byte[1024];
int len;
while ((len=bis.read(bytes))!=-1){//客户端未关闭通道，无法读到结束标记，需要客户端手动发送
    bos.write(bytes,0,len);//写入缓冲区
    bos.flush();//刷出去
}
//4.回写数据
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
bw.write("上传成功");
bw.newLine();
bw.flush();
//释放资源
socket.close();//关连接
ss.close();//关服务器
```

# 接口组成更新

## 接口默认方法

定义格式

* public default 返回值类型 方法名(参数列表){}

注意事项

* 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字
* public可以省略，default不能省略

## 接口静态方法

格式

* public static 返回值类型 方法名(参数列表){}

注意事项

* 静态方法**只能通过接口名调用**，不能通过实现类或者对象名调用

## 接口中私有方法

格式

* 格式1：private 返回值类型 方法名(参数列表){}
* 格式2：private static 返回值类型 方法名（参数列表）{}

注意事项

* 默认方法可以调用私有的静态方法和非静态方法
* 静态方法只能调用私有的静态方法

# 方法引用

## 方法引用符

* :: 该符号为引用运算符，而他所在的表达式被称为方法引用
* Lambda表达式：usePrintable(S->System.out.println(s));
* 方法引用：usePrintable(System.out::println)

推导与省略

* 如果使用Lambda,那么根据”可推到就是可省略“的原则，无需指定参数类型，也无需指定重载形式，他们都将被自动推导
* 如果使用方法引用，也是同样可以根据上下文进行推导

## 引用类方法

* 格式：类名::静态方法
* Integer::parselnt

  integer类的方法：public static int parseint(String)将此String转换为int类型数据

```
public interface showint {
    void show(String s);
}
```

```java
    public static void main(String[] args) {
show(s -> System.out.println(s));
show(System.out::println);
    }

    public static void show(showint s){
s.show("666");}
}
```

Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数

## 引用对象的实例方法

引用对象的实例方法，就是引用类中的成员方法

* 对象::成员方法

用对象的同结构实例方法。换接口重写的唯一方法。接口的抽象方法的形参 全部传给对象的实例方法的形参

```java
public interface printtt {
    void showshow(String s);
}
```

```java
public class deom {
    public static void main(String[] args) {
method(s-> System.out.println());
//实例对象的唯一方法以及对应参数，重写了抽象类的唯一抽象方法，得到调用而无歧义、
//抽象方法的形式参数全部传给唯一方法
Lei l=new Lei();
method(l::show);
}
	public static void method(printtt p){
p.showshow("llll");
    }
}
//打印类
class Lei{
    public void show(String s){
System.out.println(s);
    }
}
```

## 引用类的实例方法

```
    public static void main(String[] args) {
method(Imp::sub);
    }

    public static void method(subs s){
s.sub("woshixh",1,3);
    }

}
```

```java
public class Imp {
    public static void sub(String s, int x, int y) {
System.out.println(s.substring(x, y));
    }
}
```

```java
public interface subs {
    void sub(String s,int x,int y);
}
```

## 引用类的构造器

引用构造器，其实就是引用构造方法

接口类

```java
public interface StudentBuilder {
    Student build(String name,int age);
}
```

```java
public class main {
    public static void main(String[] args) {
useStudnetBuilder((name,age)->new Student(name,age));
//引用构造器
//抽象类中有唯一方法，为返回某类对象。则可以直接用某类对象的对应参数的类构造器代替
useStudnetBuilder(Student::new);
//Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数
    }

    public static void useStudnetBuilder(StudentBuilder sb){
Student s = sb.build("林青霞", 30);
System.out.println(s.getName()+s.getAge());
    }
}
```

# 函数式接口

## Supplier

Supplier `<T>`:包含一个无参方法

* T get():获得结果
* 该方法不需要参数，由lambda表达式实现，返回一个参数

```java
public class main {
    public static void main(String[] args) {
method(()->"123");
    }
    public static  void method(Supplier<String> p){
String str = p.get();
System.out.println(str);
    }
}
```

```java
/*
返回数组最大值
 */
public class maxTest {
    public static void main(String[] args) {
int[] arr={19,20,30,40,50};
int a=max(()->{
    int max=arr[0];
    for (int i = 1; i < arr.length; i++) {
if(arr[i]>max){
    max=arr[i];
}
    }
    return  max;
});
System.out.println(a);
    }
    public static int max(Supplier<Integer> s){
return s.get();
    }
}
```

## Consumer

Consumer `<T>`：包含两个方法

* void acceppt(T t)：对给定的参数执行此操作
* default Consumer `<T>` andThen(Consumer after)：返回一个组合的Consumer，依次执行此操作

```java
public class main {
    public static void main(String[] args) {
opratorString("hhhh", System.out::println);
opratorStringtwo("hhhhh", System.out::println, System.out::println);
    }

    //定义一个方法，消费一个字符串数据
    public static void opratorString(String name, Consumer<String> con){
con.accept(name);
    }//定义一个方法，消费一个字符串数据两次
    public static void opratorStringtwo(String name, Consumer<String> con1,Consumer<String> con2){
con1.andThen(con2).accept(name);
    }
}
```

## Predicate

Predicate `<T>`：常用的四个方法

* boolean test(T t):对给定参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值
* default Predicate `<T>` nwgate()：返回一个逻辑否定，对应逻辑非
* default Predicate `<T>` and(Predicate other)：返回一个组合判断，对应短路与
* default Predicate `<T>` or(Predicate other)：返回一个组合判断，对应短路或
* Predicate `<T>`接口常用于判断参数是否满足指定的条件

```java
public static void main(String[] args) {
    String[] strArray={"林青霞,30","柳岩,34","张曼玉,35"};
    ArrayList<String> r = ar(strArray, s -> s.split(",")[0].length() > 2
    , s -> Integer.parseInt(s.split(",")[1]) > 33);
    System.out.println(r);
}

public static ArrayList<String> ar(String[] strArray,Predicate<String> p1,Predicate<String> p2){
    ArrayList<String> arrayList=new ArrayList<>();
    for(String str:strArray){
if(p1.and(p2).test(str)){
    arrayList.add(str);
}
    }
    return  arrayList;

}
```

## Function

Function<T,R>：常用的两个方法

* R apply(将此函数用于给定参数)
* default `<V>` Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果
* Function<T,R>接口通常用于对参数进行处理，转换，然后返回一个新的值

# Stream流

## Stream流的生成方式

* 生成流
  * 通过数据源(集合，数组)生成流
  * list.stream
* 中间操作
  * 一个流后面可以跟随零个或多个中间操作，其目的主要式打开流，做出某种程度的数据过滤/映射，然后返回一个新的流交给下一个操作使用
  * filter()
* 终结操作
  * 一个流只能有一个终结操作，当这个操作执行后，流就被使用”光“了，无法再被操作，所以这必定是流的最后一个操作。再往下要调用这个流时，需要重新赋值
  * forEach()，

Stream流的常见生成方式

* Collection体系的集合可以使用默认方法stream()生成流default Steam `<E>` stream()
* Map体系的集合间接的生成流
* 数组可以通 过Stream接口的静态方法of(T...values)生成流

Stream流常见中间操作方式

* Stream `<T>` filter(Predicate predicate)：用于对流中的数据进行过滤
  * Predicate接口中的方法   boolean test(T t)：对给定的参数进行判断，返回一个布尔值

```java
 public static void main(String[] args) {
ArrayList<String> list=new ArrayList<>();
list.add("林青霞");
list.add("张曼玉");
list.add("留言");
list.add("林冲");
list.add("林a");
//把list集合中以张开头的元素在控制台输出
Stream<String> liststream = list.stream();
liststream.filter(s->s.startsWith("林")).forEach(System.out::println);
System.out.println("----------------");
//长度为三的
liststream = list.stream();
liststream.filter(s->s.length()==3).forEach(System.out::println);
System.out.println("-----------------");
//为三且张开头
liststream = list.stream();
liststream.filter(s->s.startsWith("林")).filter(s->s.length()==3).forEach(System.out::println);
    }
}
```

## 中间操作之limit&skip

* Stream `<T>` limit(long maxSize)：返回此流中的元素组成的流，截取前指定参数个数的数据
* Stream `<T>` skip(long m)：跳过指定参数个数的数据，返回由该流剩余元素组成的流

```java
//取前三元素在控制台输出
Stream<String> liststream = list.stream();
liststream.limit(3).forEach(System.out::println);
//跳过前3个元素
liststream = list.stream();
liststream.skip(3).forEach(System.out::println);
//跳2，取前2
liststream = list.stream();
liststream.skip(2).limit(2).forEach(System.out::println);
```

## 中间操作concat&distict

* staticr `<T>` Stream `<t>`concat(Stream a,Stream b)：合并a和b两个流为一个流
* Stream `<T>` distinct()：返回由该留的不同元素（根据Objectequals(Object）组成的流

```java
//取前4个数据组成一个流
Stream<String> s1 = list.stream().limit(4);
//跳过前2组成一个流
Stream<String> s2 = list.stream().skip(2);
//合并1，2的流，输出到控制台
//Stream.concat(s1,s2).forEach(System.out::println);
//合并12的流，并把结果输出，不能重复
Stream.concat(s1,s2).distinct().forEach(System.out::println);
```

## sorted

Stream `<T>` sorted():返回由刺溜的元素组成的流，根据自然顺序排序

Stream `<T>` sorted(Comparator comparator)：返回由该流的元素组成的流，根据提供的Compatator进行排序

```java
public class StreamDemo01 {
    public static void main(String[] args) {
ArrayList<String> list = new ArrayList<>();
list.add("1111");
list.add("2222");
list.add("3333");
list.add("44444");
list.add("5555");
list.add("66666");

list.stream().sorted((s1,s2)->{
   int num=s1.length()-s2.length();
   int num2=num==0?s1.compareTo(s2):num;
   return num2;
}).forEach(System.out::println);
    }
}
```

## map&mapToInt

* `<R>` Stream `<R>`map(Function mapper）：返回由给定函数应用此流的元素的结果组成的流

  R apply(T t)
* InStream mapTolnt(ToIntFuntion mapper)：返回一个InsSteam其中包含将给定函数应用于此流的元素的结果

  IntStream：表示原始int流

  ToIntFuncton接口中的方法   int applyAsInt(T value)

```java
//将集合中的字符串数据转换为整数之后在控制台输出
//list.stream().map(Integer::parseInt).forEach(System.out::println);
//list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);

//int sum()返回此流中元素的集合
int sum = list.stream().mapToInt(Integer::parseInt).sum();
System.out.println(sum);
```

## forEach&count

* long count()：返回此流中的元素数

## 收集操作

R collection(Collector collector)

* public static `<T>` Collector toList：把元素收集到List集合中
* public static `<T>` Collector toSet：把元素收集到Set集合中
* public static Collector toMap(Function keyMapper,Function valueMapper)把元素收集到Map集合中

```java
ArrayList<String> list = new ArrayList<>();
list.add("11");
list.add("22");
Stream<String> liststream = list.stream();
List<String> streamlist = liststream.collect(Collectors.toList());

Set<String> set=new HashSet<>();
set.add("1");
set.add("2");
Stream<String> setstream = set.stream();
Set<String> streamset = setstream.collect(Collectors.toSet());

String[] strArray={"林青霞,39","张鳗鱼，20"};
Stream<String> strStream = Stream.of(strArray).filter(s -> s.length() > 3);
Map<String, String> map = strStream.collect(Collectors.toMap(s -> s.split(",")[0], s -> s.split(",")[1]));
```

# 反射

反射的作用

1. 获取任意以一个类中的所有信息
2. 结合配置文件动态创建对象

获得class字节码文件对象的三种方式

1. Class.forName("全类名");
2. 类名.class
3. 对象.getClass

## 获取Class类的对象

1.类名.class

```JAVA
Class<Student> c1=Student.class;
```

2.实例对象.getClass()

```java
Student s = new Student();
    Class<? extends Student> c3 =s.getClass();
```

3.Class.forName("全类名")

```java
Class<?> c4 = Class.forName("P16.Student");
System.out.println(c1==c4);
```

## 获取构造方法

getConstructors()：返回所有公共构造方法对象的数组

```java
Constructor<?>[] cons = c.getConstructors();
```

getDeclaredConstructors()：返回所有构造方法对象的数组

```java
Constructor<?>[] cons =getDeclaredConstructors()
```

getConstructor(Class<?>...parameterTypes)：返回单个公共构造方法对象

```java
Constructor<?>[] cons = c.getDeclaredConstructors();
```

getDeclaredConstructor(Class `<T>`...parameterTypes)：返回单个构造对象

```java
Constructor<?>[] cons = c.getConstructors();
```

T newInstance(Object...initargs)：根据指定方法创建对象

```java
Object obj=con.newInstance();
```

> 基本数据类型也可以通过class得到对应的Class类型
>
> ```java
> //获取带参构造方法对象
> Constructor<?> con = c.getConstructor(int.class, String.class);
> ```

## 获取成员变量

Class类中用于获取成员变量的方法

* Field getFields()：返回所有公共成员变量对象的数组
* Field[] getDeclaredFields()：返回所有成员变量对象的数组
* Field getField(String name)：返回单个公共成员变量对象
* Field getDeclaredField(String name)：返回单个成员变量对象

Field类中用于给成员变量成员变量赋值的方法

* void set(Object obj, Object value)：给obj对象的成员变量赋值为value

```java
Class<?> c = Class.forName("P16.Student");
//返回所有公共成员变量对象的数组
Field[] fields = c.getFields();
//返回所有私有变量对象的数组
Field[] declaredFields = c.getDeclaredFields();
//返回一个公共成员。
Field ageField = c.getField("age");
//返回一个私有成员
Field ageField = c.getDeclaredField;
//无参方法创造对象
Constructor<?> con = c.getConstructor();//获取构造方法
Object obj = con.newInstance();//构造对象
//修改成员变量
ageField.set(obj,12);
```

> 取消此私有成员变量的检查：ageField.setAccessible(true);

## 获取方法

# 代理

生成代理对象的工具类

```java
/*给一个明星对象，创建一个代理
形参：被代理的对象
返回值：被代理对象的代理*/
public static Star createProxy(BigStar bigStar) {
    Star star = (Star) Proxy.newProxyInstance(
            ProxyUtil.class.getClassLoader(),//类加载器
            new Class[]{Star.class},//代理的方法的接口
            new InvocationHandler() {//新的方法
                /*
                参数1:代理的对象
                参数2:代理的方法
                参数3:代理的方法的参数
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    if ("sing".equals(method.getName())) {
                        System.out.println("准备话筒，收钱");
                    } else if ("jump".equals(method.getName())) {
                        System.out.println("准备场地，收钱");
                    }
                    return method.invoke(bigStar, args);
                }
            }
    );
    return star;
};
```

star.interface|要代理的方法的接口

```java
public interface Star {
    public abstract void sing();
    public abstract void jump();
}
```

main.java 调用

```java
BigStar bigStar = new BigStar();
Star proxy = ProxyUtil.createProxy(bigStar);
proxy.jump();
proxy.sing();
```

## 类加载器

当程序要使用某个类时，如果该类还未被架子啊到内存中，则系统会通过类的加载，类的连接，类的初始化三个步骤对类进行初始化。JVM将会连续完成这三个步骤

类的加载

* 将class文件读入内存，并为之创一个java.lang.Class对象
* 任何类被使用时，系统都会为之建立一个java.lang.Class对象

类的连接

* 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致
* 准备阶段：负责为类的变量分配内存，并设置默认初始化值
* 解析阶段：将类的二进制数据中的符号引用替换为直接引用

类的初始化

* 在该阶段，主要就是对类变量进行初始化

# 模块

模块导出：exports 包名

依赖：requires 模块名

服务提供 provides 接口 with 实现类

声明服务接口 ：uses 接口

ServiceLoader：一种加载服务实现的

# 练习

## 复制图片

```JAVA
FileOutputStream fos=new FileOutputStream("D:/1/3_copy.jpg");
FileInputStream fis=new FileInputStream("D:/1/3.jpg");
int len;
byte[] bys=new byte[1024];
while((len= fis.read(bys))!=-1){
    fos.write(bys,0,len);
}
```

## 复制文件夹

```java
private static void copydir(File src, File dest) throws IOException {
    //递归
    if (src.isFile()) {
        FileInputStream fis = new FileInputStream(src);
        FileOutputStream fos = new FileOutputStream(dest);
        byte[] bytes = new byte[1024];
        int len;
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes, 0, len);
        }
        fos.close();
        fis.close();
    } else {
        //源是文件夹
        //在目标处创建文件夹
        dest.mkdirs();
        if (src != null) {
            //遍历源文件夹
            File[] files = src.listFiles();
            for (File file : files) {
                File sonfile = new File(dest, file.getName());
                copydir(file, sonfile);
            }
        }
    }
}
```
