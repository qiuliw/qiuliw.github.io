---
title: 循环和关系表达式
date: 2024/06/28 11:34
categories:
  - 读书笔记
tags:
  - Cpp
---
# 循环和关系表达式

## 1 for循环

### 1.6 副作用与顺序点

增和递减运算符是处理将值加减1这种常见任务的一种简约、方便的方法。
递增运算符和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于，规则“使用后修改”和“修改后使用”可能会变得模糊不清。也就是说，下面这条语句在不同的系统上将生成不同的结果：

```cpp
x = 2*x++ *(3 - ++x);
```

对这种语句，C++没有定义正确的行为。

==副作用（side effect）==指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；
==顺序点（sequence point）==是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。

在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。

任何完整的表达式末尾都是一个顺序点。

```cpp
y = (4 + x++) + (6+ x++)
```

表达式4 + x++不是一个完整表达式，因此，C++不保证x的值在计算子表达式4 + x++后立刻增加1。在这个例子中，整条赋值语句是一个完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。C++没有规定是在计算每个子表达式之后将x的值递增，还是在整个表达式计算完毕后才将x的值递增，有鉴于此，您应避免使用这样的表达式。

::: tip 
在C++11文档中，不再使用术语“顺序点”了，因为这个概念难以用于讨论多线程执行。相反，使用了术语“顺序”，它表示有些事件在其他事件前发生。这种描述方法并非要改变规则，而旨在更清晰地描述多线程编程。
:::

### 1.7 前缀格式和后缀格式

下面两条语句的作用是否不同？
```cpp
for(n = lim; n>0; --n)...;
for(n = lim; n>0; n--)...;
```

从逻辑上说，在上述两种情形下，使用前缀格式和后缀格式没有任何区别。表达式的值未被使用，因此只存在副作用。在上面的例子中，使用这些运算符的表达式为完整表达式，因此将x加1和n减1的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同。

然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而言，这看似不是什么问题。然而，C++允许您针对类定义这些运算符，在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因此，对于类而言，前缀版本的效率比后缀版本高。

总之，对于内置类型，采用哪种格式不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，则==前缀格式的效率更高。==

## 4 基于范围的for循环（C++11）

C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作，如下例所示：

```cpp
double prices[5] = {4.99,10.99,6.87,7.99,8,49}
for(double x : prices)
	cout << x << std:endl
```

其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素，每个元素占据一行。总之，该循环显示数组中的每个值。

要修改数组的元素，需要使用不同的循环变量语法：
```cpp
for(double &x : prices)
	x=x*0.80;
```

符号&表明x是一个引用变量，这个主题将在第8章讨论。就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。

## 5 循环和文本输入

### 5.4 文件尾条件

**get()的重载**

```cpp
char ch;
cin.get(ch); // fucntion get(char &c); 函数重载，传入参数不是地址时，是直接变量时，调用形参为引用变量的get函数
```

如果熟悉C语言，可能以为这个程序存在严重的错误！cin.get(ch)调用将一个值放在ch变量中，这意味着将修改该变量的值。在C语言中，要修改变量的值，必须将变量的地址传递给函数。但程序清单5.17调用cin.get( )时，传递的是ch，而不是&ch。在C语言中，这样的代码无效，但在C++中有效，只要函数将参数声明为引用即可。引用是C++在C语言的基础上新增的一种类型。头文件iostream将cin.get(ch)的参数声明为引用类型，因此该函数可以修改其参数的值。我们将在第8章中详细介绍。同时，C语言行家可以松一口气了—通常，在C++中传递的参数的工作方式与在C语言中相同。然而，cin.get(ch)不是这样。

**使用fail( )检测EOF**

使用诸如#等符号来表示输入结束很难令人满意，因为这样的符号可能就是合法输入的组成部分，其他符号（如@和%）也如此。如果输入来自于文件，则可以使用一种功能更强大的技术—检测文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。

用文件替换键盘输入。例如，假设在Windows中有一个名为gofish.exe的可执行程序和一个名为fishtale的文本文件，则可以在命令提示符模式下输入下面的命令：
```cpp
gofish < fishtable
```

这样，程序将从fishtale文件（而不是键盘）获取输入。`<` 符号是Unix和Windows命令提示符模式的重定向运算符。

检测到EOF后，cin将两位（eofbit和failbit）都设置为1。

`cin.eof( )`、`fail( )` 获取 eofbit和failbit 的值

注意，eof( )和fail( )方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof( )或cin.fail( )测试放在读取后

`fail( )` 用于更多的实现中。

```cpp
#include <iostream>

int main(){
    using namespace std;
    char ch;
    int count = 0;
    cin.get(ch);
    while (cin.fail() == false ){ // text EOF
        cout << ch;
        ++ count;
        cin.get(ch);
    }
    cout << endl;
}
```

**使用char比较EOF**

可以使用int ch，并用cin.get( )代替cin.get(char)，用cout.put( )代替cout，==用EOF测试代替cin.fail( )测试：==
```cpp
int ch;
ch = cin.get();
while(ch != EOF){
	cout.put(ch);
	++count;
	ch = cin.get();
}
```

**使用int比较EOF**

除了当前所做的修改外，关于使用cin.get( )还有一个微妙而重要的问题。由于EOF表示的不是有效字符编码，因此可能不与char类型兼容。例如，在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值（−1）。由于这种原因，==如果使用cin.get( )（没有参数）并测试EOF，则必须将返回值赋给int变量，而不是char变量==。另外，如果将ch的类型声明为int，而不是char，则必须在显示ch时将其强制转换为char类型。以下是优化后的

```cpp
#include <iostream>

int main(void){
    using namespace std;
    int ch;
    int count = 0;
    while ((ch = cin.get()) != EOF ){ 文件结束测试
        cout.put(char(ch))
        ++ count;
    }
    cout << endl;
    return 0;
}
```

::: tip cin.get(ch)不会将非字符赋值给ch
使用cin.get(ch)（有一个参数）进行输入时，将不会导致任何类型方面的问题。前面讲过，cin.get(char)函数在到达EOF时，不会将一个特殊值赋给ch。事实上，在这种情况下，它不会将任何值赋给ch。ch不会被用来存储非char值。
:::

**表5.3 cin.get(ch)与cin.get( )**

| 属性            | cin.get(ch)                | cin.get()  |
| ------------- | -------------------------- | ---------- |
| 传递输入字符的方式     | 赋给参数ch                     | 将函数返回值赋给ch |
| 用于字符输入时函数的返回值 | istream对象（执行bool转换后为true）  | int类型的字符编码 |
| 到达EOF时函数的返回值  | istream对象（执行bool转换后为false） | EOF        |

**那么应使用cin.get( )还是cin.get(char)呢？**

使用字符参数 `cin.get(char)` 的版本更符合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起来。例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下来的一个字符读入到ch2中：

```cpp
cin.get(ch1).get(ch2);
```


